def application(environ, start_response):
    import cgi
    import json
    import hashlib

    # Set top folder to allow import of modules

    import os, sys, inspect

    top_folder = \
        os.path.split(os.path.realpath(os.path.abspath(os.path.split(inspect.getfile(inspect.currentframe()))[0])))[0]
    if top_folder not in sys.path:
        sys.path.insert(0, top_folder)

    import inventorylib
    from iiutilities import dblib, datalib
    from iiutilities.utility import unmangleAPIdata
    from time import time

    post_env = environ.copy()
    post_env['QUERY_STRING'] = ''
    post = cgi.FieldStorage(
        fp=environ['wsgi.input'],
        environ=post_env,
        keep_blank_values=True
    )

    formname = post.getvalue('name')
    output = {}
    d = {}
    for k in post.keys():
        d[k] = post.getvalue(k)

    status = '200 OK'
    # Run stuff as requested
    # We use the dynamic function to allow various  
    # types of queries
    output['data'] = []
    output['message'] = ''

    print('original')
    print(d)
    d = unmangleAPIdata(d)
    print('unmanged')
    print(d)

    # Here we verify credentials of session data against those in the database.
    # While we authenticate in the browser, this does not stop POST queries to the API without the page provided
    # So we take the hpass stored in the dictionary and verify

    # First, let's get our pathalias and translate to a path, using our path reloader

    if 'pathalias' in d:
        output['message'] += inventorylib.reloaddatapaths(pathalias=d['pathalias'])
    else:
        output['message'] += 'No pathalias found in dictionary. '

    wsgiauth = False
    authverified = False

    if wsgiauth:
        # Verfiy that session login information is legit: hashed password, with salt and username, match
        # hash stored in database.
        import hashlib

        if 'sessionuser' in d:
            output['message'] += 'Session user is ' + d['sessionuser'] + '. '
        else:
            output['message'] += 'No session user found. '
            d['sessionuser'] = ''

        try:
            condition = "name='" + d['sessionuser'] + "'"
            userdata = dblib.readonedbrow(inventorylib.sysvars.dirs.dbs.safe, 'users', condition=condition)[0]
        except:
            output['message'] += 'error in user sqlite query for session user "' + d['sessionuser'] + '". '
            userdata = {'accesskeywords':'demo','admin':False}
        else:
            # Get session hpass to verify credentials
            hashedpassword = d['sessionhpass']
            hname = hashlib.new('sha1')
            hname.update(d['sessionuser'])
            hashedname = hname.hexdigest()
            hentry = hashlib.new('md5')
            hentry.update(hashedname + datalib.salt + hashedpassword)
            hashedentry = hentry.hexdigest()
            if hashedentry == userdata['password']:
                # successful auth
                output['message'] += 'Password verified. '
                authverified = True
    else:
        output['message'] += 'WSGI authorization not enabled. '

    if authverified or not wsgiauth:
        try:
            action = d['action']
        except KeyError:
            output['message'] = 'no action in request'
        else:
            # Stock functions
            if action == 'addeditpart':
                output['message'] += 'addpart keyword found. '
                output = inventorylib.addeditstockpart(d, output)
                inventorylib.recalcpartdata(stock='stock')
            elif action == 'copypart':
                output['message'] += 'copypart keyword found. '
                output = inventorylib.copystockpart(d, output)
                inventorylib.recalcpartdata(stock='stock')
            elif action == 'deleteparts':
                output['message'] += 'deleteparts keyword found. '
                output = inventorylib.deletestockparts(d, output)
                inventorylib.recalcpartdata(stock='stock')

            # Inventory functions

            # Edit and add are separated, as names are autogenerated
            elif action == 'editinventory':
                output['message'] += 'editinventory keyword found. '
                output = inventorylib.editinventory(d, output)
                inventorylib.calcstockfromall()
            elif action == 'addinventory':
                output['message'] += 'addinventory keyword found. '
                output = inventorylib.createnewinventory(d, output)
                inventorylib.makeinventorymetadata()
                inventorylib.calcstockfromall()
            elif action == 'deleteinventories':
                output['message'] += 'deleteinventories keyword found. '
                output = inventorylib.deleteinventories(d, output)
                inventorylib.makeinventorymetadata()
                inventorylib.calcstockfromall()
            elif action == 'addeditinventorypart':
                output['message'] += 'addeditinventorypart keyword found. '
                output = inventorylib.addeditpartlist(d, output)
                inventorylib.makeinventorymetadata()
                inventorylib.calcstockfromall()
            elif action == 'deletepartsfrominventory':
                output['message'] += 'deletepartsfrominventory keyword found. '
                output = inventorylib.deletepartsfrominventory(d, output)
                inventorylib.makeinventorymetadata()
                inventorylib.calcstockfromall()

            # Order functions
            elif action == 'editorder':
                output['message'] += 'editorder keyword found. '
                output = inventorylib.editorder(d, output)
                inventorylib.makeordermetadata()
                inventorylib.calcstockfromall()
            elif action == 'addorder':
                output['message'] += 'addorder keyword found. '
                output = inventorylib.createneworder(d, output)
                inventorylib.makeordermetadata()
                inventorylib.calcstockfromall()
            elif action == 'deleteorders':
                output['message'] += 'deleteorders keyword found. '
                output = inventorylib.deleteorders(d, output)
                inventorylib.makeordermetadata()
                inventorylib.calcstockfromall()
            elif action == 'addeditorderpart':
                output['message'] += 'addeditorderpart keyword found. '
                output = inventorylib.addeditpartlist(d, output)
                inventorylib.makeordermetadata()
                inventorylib.calcstockfromall()
            elif action == 'addeditorderparts':
                output['message'] += 'addeditorderparts keyword found. '
                if 'partsdata' in d:
                    print(d)
                    # Just send through once for each additional part
                    for partdata in d['partsdata']:
                        d['partdata'] = partdata
                        output = inventorylib.addeditpartlist(d, output)
                inventorylib.makeordermetadata()
                inventorylib.calcstockfromall()
            elif action == 'deletepartsfromorder':
                output['message'] += 'deletepartsfromorder keyword found. '
                output = inventorylib.deletepartsfromorder(d, output)
                inventorylib.makeordermetadata()
                inventorylib.calcstockfromall()

            # BOM functions
            elif action == 'copybom':
                output['message'] += 'copybom keyword found. '
                output = inventorylib.copybom(d, output)
                inventorylib.makebommetadata()
            elif action == 'addeditbom':
                output['message'] += 'addeditbom keyword found. '
                output = inventorylib.addeditbom(d, output)
                inventorylib.makebommetadata()
            elif action == 'addeditbompart':
                output['message'] += 'addeditbompart keyword found. '
                output = inventorylib.addeditpartlist(d, output)
                inventorylib.makebommetadata()
            elif action == 'getbomcalcs':
                output['message'] += 'getbomcalcs keyword found. '
                output = inventorylib.calcbomprice(d, output)
            elif action == 'deletepartsfrombom':
                output['message'] += 'deletepartsfrombom keyword found. '
                output = inventorylib.deletepartsfrombom(d, output)
                inventorylib.makebommetadata()
            elif action == 'deleteboms':
                output['message'] += 'deleteboms keyword found. '
                output = inventorylib.deleteboms(d, output)
                inventorylib.makebommetadata()

            # Assembly functions
            elif action == 'copyassembly':
                output['message'] += 'copyassembly keyword found. '
                output = inventorylib.copyassembly(d, output)
                inventorylib.makeassemblymetadata()
            elif action == 'addeditassembly':
                output['message'] += 'addeditassembly keyword found. '
                output = inventorylib.addeditassembly(d, output)
                inventorylib.makeassemblymetadata()
            elif action == 'addeditassemblypart':
                output['message'] += 'addeditassemblypart keyword found. '
                output = inventorylib.addeditpartlist(d, output)
                inventorylib.makeassemblymetadata()
            elif action == 'getassemblycalcs':
                output['message'] += 'getassemblycalcs keyword found. '
                output = inventorylib.calcassemblyprice(d, output)
            elif action == 'deletepartsfromassembly':
                output['message'] += 'deletepartsfromassembly keyword found. '
                output = inventorylib.deletepartsfromassembly(d, output)
                inventorylib.makeassemblymetadata()
            elif action == 'deleteassemblys':
                output['message'] += 'deleteassemblys keyword found. '
                output = inventorylib.deleteassemblies(d, output)
                inventorylib.makeassemblymetadata()

            # Multi-use
            elif action == 'reloaditemdatafromstock':
                output['message'] += 'reloaditemdatafromstock keyword found. '
                output = inventorylib.refreshpartsfromstock(d, output)
                if 'bomname' in d:
                    inventorylib.recalcpartdata(bomname=d['bomname'])
                    inventorylib.makebommetadata()

            # Generic functions
            elif action == 'gettablenames':
                dbpath = inventorylib.dbnametopath(d['database'])
                try:
                    output['data'] = dblib.gettablenames(dbpath)
                except:
                    output['message'] += 'Error getting table names'
            elif action == 'switchtablerows':
                dbpath = inventorylib.dbnametopath(d['database'])
                dblib.switchtablerows(dbpath, d['tablename'], d['row1'], d['row2'], d['uniqueindex'])
            elif action == 'modwsgistatus':
                output['processgroup'] = repr(environ['mod_wsgi.process_group'])
                output['multithread'] = repr(environ['wsgi.multithread'])
            elif action == 'gettabledata':
                output['message']+='Gettabledata. '
                if 'database' in d:
                    dbpath = inventorylib.dbnametopath(d['database'])
                    if dbpath:
                        output['message'] += 'Friendly name ' + d['database'] + ' translated to path ' + dbpath + ' successfully. '

                        if 'tablenames[]' in d:  # Get multiple tables
                            output['message'] += 'Multiple tables. '
                            data = []
                            if 'start' in d:
                                fixedstart = int(d['start'])
                            else:
                                fixedstart = 0
                            if 'length' in d:
                                fixedlength = int(d['length'])
                            else:
                                fixedlength = 1
                            if 'lengths[]' in d:
                                lengths = map(int, d['lengths[]'])
                            else:
                                lengths = []
                            if 'starts[]' in d:
                                starts = map(int, d['starts'])
                            else:
                                starts = []

                            for index, table in enumerate(d['tablenames[]']):
                                try:
                                    length = lengths[index]
                                except IndexError:
                                    length = fixedlength
                                try:
                                    start = starts[index]
                                except IndexError:
                                    start = fixedstart

                                data.append(dblib.dynamicsqliteread(dbpath, table, start, length))
                                output['data']=data
                        elif 'length' in d:  # Handle table row subset
                            output['message']+='Length keyword. '
                            if not 'start' in d:
                                d['start'] = 0
                            thetime = time();
                            output['data'] = dblib.dynamicsqliteread(dbpath, d['tablename'], d['start'], d['length'])
                            output['querytime'] = time() - thetime
                        elif 'row' in d:  # Handle table row
                            output['message'] += 'Row keyword. ' + str(d['row'])
                            thetime = time();
                            output['data'] = dblib.dynamicsqliteread(dbpath, d['tablename'], d['row'])
                            output['querytime'] = time() - thetime
                        elif 'tablename' in d:  # Handle entire table
                            output['message'] += 'Tablename keyword: ' + d['tablename'] + '. '
                            thetime = time();
                            if 'condition' in d:
                                if not d['condition'] == '':
                                    output['data'] = dblib.dynamicsqliteread(dbpath, d['tablename'], condition=d['condition'])
                                else:
                                    output['data'] = dblib.dynamicsqliteread(dbpath, d['tablename'])
                            else:
                                try:
                                    output['data'] = dblib.dynamicsqliteread(dbpath, d['tablename'])
                                except:
                                    output['message'] += 'Error retrieving data. '
                                else:
                                    output['message'] += 'Data query appears successful. '
                            output['querytime'] = time() - thetime
                    else:
                        output['message'] += 'Friendly name ' + d['database'] + ' unsuccessfully translated. '
                else:
                    output['message'] += 'No database present in action request'
            else:
                output['message'] = 'no command matched for action ' + action
    else:
        # status = '403 Forbidden'
        output['message'] += 'Not authorized for this action. '

    if 'data' in output:
        if output['data']:
            newetag = hashlib.md5(str(output['data'])).hexdigest()
            if 'etag' in d:
                if newetag == d['etag']:
                    status = '304 Not Modified'
                    output['data'] = ''
        else:
            newetag=''
    else:
        newetag=''

    if 'datasize' in d:
        output['datasize'] = sys.getsizeof(output['data'])

    output['etag'] = newetag
    try:
        foutput = json.dumps(output, indent=1)
    except:
        import csv
        w = csv.writer(open("/usr/lib/iicontrollibs/inventory/dumperr.log", "w"))
        for key, val in output.items():
            w.writerow([key, val])

    response_headers = [('Content-type', 'application/json')]
    response_headers.append(('Etag',newetag))
    start_response(status, response_headers)

    return [foutput]

